<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Angular Data Design by jeffbcross</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Angular Data Design</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/jeffbcross/data-design" class="btn">View on GitHub</a>
      <a href="https://github.com/jeffbcross/data-design/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/jeffbcross/data-design/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="roadmap-for-data-access-and-persistence-in-angular-2" class="anchor" href="#roadmap-for-data-access-and-persistence-in-angular-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Roadmap for Data Access and Persistence in Angular 2</h1>

<p>This document describes the Angular team's goals in improving application data access and persistence. The document is meant to give a high-level overview of priorities and approaches,
without diving too deeply into implementation details and timelines.</p>

<h2>
<a id="goal" class="anchor" href="#goal" aria-hidden="true"><span class="octicon octicon-link"></span></a>Goal</h2>

<p>Help developers make more robust and resilient apps for all web users, in varying technical circumstances, while accounting for real world challenges and constraints of managing application data and assets.</p>

<h3>
<a id="more-specifically" class="anchor" href="#more-specifically" aria-hidden="true"><span class="octicon octicon-link"></span></a>More specifically...</h3>

<ul>
<li>Provide seamless and transparent user experience in the face of intermittent network connectivity

<ul>
<li>Strike a balance between completely disabling functionality, or completely hiding problems when network connectivity drops</li>
</ul>
</li>
<li>Empower users when things go wrong

<ul>
<li>Don't be afraid to say if connectivity has dropped or data synchronization has failed; provide the user options to resolve issues </li>
</ul>
</li>
<li>Easily adapt to varying bandwidth capabilities of users

<ul>
<li>Data and asset fetching should adapt what to fetch/not to fetch, or what alternatives to fetch based on current bandwidth capabilities<br>
</li>
</ul>
</li>
<li>Fast load, and high responsiveness 

<ul>
<li>Apps should be intelligent about having the right data available at the right time, to load apps quickly and improve responsiveness to user actions<br>
</li>
</ul>
</li>
</ul>

<h3>
<a id="real-world-constraints-to-consider" class="anchor" href="#real-world-constraints-to-consider" aria-hidden="true"><span class="octicon octicon-link"></span></a>Real-World Constraints to Consider</h3>

<ul>
<li>Applications support many browsers, many of which don't have the latest native APIs</li>
<li>Backend capabilities differ, in terms of what protocols are supported (Http/1.1, Http/2, WebSockets) and what types of services may be created</li>
<li>Application data often comes from many sources, not a single backend</li>
<li>The way data is structured, and the way it flows is different for every application</li>
<li>Teams building applications may be one person building an app in a week, or a large team of many developers focusing on different parts of an application for several years</li>
<li>Angular applications may run in environments other than JavaScript in a Browser (Dart, Node, iOS/Android WebViews, iOS/Android Native)</li>
<li>Optimal solutions to data access and performance depend on many factors, including but not limited to the application model, the user's current network latency, the user's current bandwidth, the user's cost for data upload/download, and the user's current processing power.</li>
</ul>

<h2>
<a id="real-world-use-cases-and-best-practices" class="anchor" href="#real-world-use-cases-and-best-practices" aria-hidden="true"><span class="octicon octicon-link"></span></a>Real World Use Cases and Best Practices</h2>

<p>The following challenges and best practices were developed to help guide the types of tools needed to provide the optimal user experience. These are meant to be general guides, not to be strict rules. An optimal user experience depends on many factors.a</p>

<h3>
<a id="fast-load-in-all-circumstances" class="anchor" href="#fast-load-in-all-circumstances" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fast Load in All Circumstances</h3>

<p>Initial load of an app should immediately provide a reasonable experience in all network conditions, assuming the app has been loaded previously.</p>

<h3>
<a id="at-least-provide-read-only-views-when-offline" class="anchor" href="#at-least-provide-read-only-views-when-offline" aria-hidden="true"><span class="octicon octicon-link"></span></a>At Least Provide Read-Only Views When Offline</h3>

<p>Even if an app decides not to allow mutating data when offline, read-only functionality should be maintained (where practical). Applications should provide cues to users if the data is especially stale, and should consider allowing optimistic mutation of data if the application model allows.</p>

<h3>
<a id="eagerly-load-data-if-practical" class="anchor" href="#eagerly-load-data-if-practical" aria-hidden="true"><span class="octicon octicon-link"></span></a>Eagerly Load Data if Practical</h3>

<p>Applications should leverage good connectivity to make data available offline even if not explicitly requested by the user, with consideration for bandwidth and battery costs to the user.</p>

<h3>
<a id="jank-free-ui" class="anchor" href="#jank-free-ui" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jank-Free UI</h3>

<p>The UI should never block user interactivity or hang on network activity.</p>

<h3>
<a id="zero-perceived-latency-responsiveness" class="anchor" href="#zero-perceived-latency-responsiveness" aria-hidden="true"><span class="octicon octicon-link"></span></a>Zero-Perceived-Latency Responsiveness</h3>

<p>Application should acknowledge every user interaction in &lt;100 ms. Navigation, form submission, changing tabs. </p>

<h3>
<a id="work-with-users" class="anchor" href="#work-with-users" aria-hidden="true"><span class="octicon octicon-link"></span></a>Work with Users</h3>

<p>Application should provide clear indications of how connectivity is affecting performance and other capabilities.</p>

<h3>
<a id="refresh-survival" class="anchor" href="#refresh-survival" aria-hidden="true"><span class="octicon octicon-link"></span></a>Refresh Survival</h3>

<p>Application state should survive an OS-imposed refresh, even when offline and with a dirty view.</p>

<h3>
<a id="intelligent-uninterrupted-experience-with-varying-bandwidth" class="anchor" href="#intelligent-uninterrupted-experience-with-varying-bandwidth" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intelligent, Uninterrupted Experience with Varying Bandwidth</h3>

<p>Application should gracefully transition between experiences optimized for connections with low bandwidth and high bandwidth</p>

<h3>
<a id="optimistic-transparent-mutations" class="anchor" href="#optimistic-transparent-mutations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optimistic, Transparent Mutations</h3>

<p>Application should make clear when committed model mutations have not been confirmed as persisted to remote data source, especially when further mutations are being made.</p>

<h3>
<a id="first-class-cache" class="anchor" href="#first-class-cache" aria-hidden="true"><span class="octicon octicon-link"></span></a>First-Class Cache</h3>

<p>Applications should cache as much as possible, and read from cache as much as possible, using network communication sparingly, even if only portions of a model are able to be cached or read from cache. </p>

<h3>
<a id="data-aware-navigation" class="anchor" href="#data-aware-navigation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data-Aware Navigation</h3>

<p>Applications should wait until a new view has enough data to render before destroying a previous view and rendering the new view. And should not automatically navigate if operation takes too long, but prompt user to manually navigate to new view.</p>

<h2>
<a id="layers-of-solutions" class="anchor" href="#layers-of-solutions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Layers of Solutions</h2>

<p>Not all of the above best practices can be solved by frameworks or libraries, but the design of Angular core can be considered in ways that make these best practices more within reach for developers. These are the layers at which these best practices are being made more possible to achieve: </p>

<ul>
<li>Good core support

<ul>
<li>The highest priority is to make the core of Angular 2 play nicely with all kinds of data, regardless of how it's structured, how it's wrapped, where it comes from, or how it gets to the app. Two existing examples of these solutions are <a href="https://angular.io/docs/js/latest/api/pipes/">pipes</a> and <a href="https://github.com/angular/zone.js/">zones</a>, with more solutions being designed or considered, such as deeper integration of services with Angular's router and compiler to support prioritized data fetching and rendering, as well as support server-side rendering.</li>
</ul>
</li>
<li>Browser Wrappers

<ul>
<li>Browsers now provide many tools to solve hard problems with data, such as persistence and asset caching. These tools are not always easy to use, and often difficult to test. Here are some native APIs for which Angular will provide thin wrappers around, as well as the approach being taken in the implementation:

<ul>
<li>HTTP APIs (Status: In-progress, <a href="https://github.com/angular/angular/commit/21568106b114943b59ce37832d82c8fb9a63285b">first commit</a>) (<code>[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)</code>, <code>[fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)</code>, etc). Wrappers will provide a composable, Observable-based interface, as well as simplify the process of performing a request. The abstraction will improve mocking and testability, and will make it possible to create isomorphic code to run in different environments (JS in browser, JS in node, Dart, ServiceWorker, etc) by replacing the underlying transport (i.e. <code>XMLHttpRequest</code>) using dependency injection. The Http library will provide conveniences to simplify the use of techniques such as request retrying, short polling, long polling, and request cancellation. It will also focus on reducing boilerplate and complexity for projects and teams of all sizes.</li>
<li>LocalStorage and SessionStorage (Status: Planned): These APIs will provide mocks to allow testing code without interacting with real browser storage APIs. The abstraction will also provide an <a href="https://github.com/zenparsing/es-observable">Observable</a> interface on top of the APIs, which will allow subscription to changes to values in the store, specified by key.</li>
<li>IndexedDB (Status: Planned)</li>
<li>WebSocket (Status: Planned)</li>
<li>ServiceWorker/AppCache</li>
</ul>
</li>
</ul>
</li>
<li>First-Class Libraries

<ul>
<li>Network State (Status: Research)</li>
<li>Task Scheduler (Status: Research)</li>
<li>Model Metadata (Status: Research)</li>
<li>View State Preservation (Status: Research) i.e. preserve the in-memory model and scroll position to survive OS-forced refresh on mobile browsers where memory is scarce.</li>
</ul>
</li>
<li>First-Class and Third-Party Data Frameworks

<ul>
<li>Tactical</li>
<li>Falcor</li>
<li>Firebase/AngularFire</li>
<li>Angular-Meteor</li>
<li>Restangular</li>
<li>Lovefield</li>
<li>BreezeJS</li>
<li>etc</li>
</ul>
</li>
</ul>

<h2>
<a id="further-reading" class="anchor" href="#further-reading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Further Reading</h2>

<ul>
<li>
<a href="https://github.com/jeffbcross" class="user-mention">@jeffbcross</a> and <a href="https://github.com/synalx" class="user-mention">@synalx</a> present <a href="https://www.youtube.com/watch?v=Bm3eDgZZMFs">The Future of Data in Angular</a> at ng-vegas 2015.</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jeffbcross/data-design">Angular Data Design</a> is maintained by <a href="https://github.com/jeffbcross">jeffbcross</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-40960703-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>


{"name":"Angular Data Design","tagline":"","body":"# Roadmap for Data Access and Persistence in Angular 2\r\n\r\nThis document describes the Angular team's goals in improving application data access and persistence. The document is meant to give a high-level overview of priorities and approaches,\r\nwithout diving too deeply into implementation details and timelines.\r\n\r\n## Goal\r\n\r\nHelp developers make more robust and resilient apps for all web users, in varying technical circumstances, while accounting for real world challenges and constraints of managing application data and assets.\r\n\r\n### More specifically...  \r\n\r\n * Provide seamless and transparent user experience in the face of intermittent network connectivity\r\n   * Strike a balance between completely disabling functionality, or completely hiding problems when network connectivity drops\r\n * Empower users when things go wrong\r\n   * Don't be afraid to say if connectivity has dropped or data synchronization has failed; provide the user options to resolve issues \r\n * Easily adapt to varying bandwidth capabilities of users\r\n   * Data and asset fetching should adapt what to fetch/not to fetch, or what alternatives to fetch based on current bandwidth capabilities  \r\n * Fast load, and high responsiveness \r\n   * Apps should be intelligent about having the right data available at the right time, to load apps quickly and improve responsiveness to user actions   \r\n\r\n### Real-World Constraints to Consider\r\n\r\n * Applications support many browsers, many of which don't have the latest native APIs\r\n * Backend capabilities differ, in terms of what protocols are supported (Http/1.1, Http/2, WebSockets) and what types of services may be created\r\n * Application data often comes from many sources, not a single backend\r\n * The way data is structured, and the way it flows is different for every application\r\n * Teams building applications may be one person building an app in a week, or a large team of many developers focusing on different parts of an application for several years\r\n * Angular applications may run in environments other than JavaScript in a Browser (Dart, Node, iOS/Android WebViews, iOS/Android Native)\r\n * Optimal solutions to data access and performance depend on many factors, including but not limited to the application model, the user's current network latency, the user's current bandwidth, the user's cost for data upload/download, and the user's current processing power.\r\n\r\n\r\n## Real World Use Cases and Best Practices\r\n\r\nThe following challenges and best practices were developed to help guide the types of tools needed to provide the optimal user experience. These are meant to be general guides, not to be strict rules. An optimal user experience depends on many factors.a\r\n\r\n### Fast Load in All Circumstances\r\n\r\nInitial load of an app should immediately provide a reasonable experience in all network conditions, assuming the app has been loaded previously.\r\n\r\n### At Least Provide Read-Only Views When Offline\r\n\r\nEven if an app decides not to allow mutating data when offline, read-only functionality should be maintained (where practical). Applications should provide cues to users if the data is especially stale, and should consider allowing optimistic mutation of data if the application model allows.\r\n\r\n### Eagerly Load Data if Practical \r\n\r\nApplications should leverage good connectivity to make data available offline even if not explicitly requested by the user, with consideration for bandwidth and battery costs to the user.\r\n\r\n### Jank-Free UI\r\n\r\nThe UI should never block user interactivity or hang on network activity.\r\n\r\n### Zero-Perceived-Latency Responsiveness\r\n\r\nApplication should acknowledge every user interaction in &lt;100 ms. Navigation, form submission, changing tabs. \r\n\r\n### Work with Users \r\n\r\nApplication should provide clear indications of how connectivity is affecting performance and other capabilities.\r\n\r\n### Refresh Survival \r\n\r\nApplication state should survive an OS-imposed refresh, even when offline and with a dirty view.\r\n\r\n### Intelligent, Uninterrupted Experience with Varying Bandwidth\r\n\r\nApplication should gracefully transition between experiences optimized for connections with low bandwidth and high bandwidth\r\n\r\n### Optimistic, Transparent Mutations\r\n\r\nApplication should make clear when committed model mutations have not been confirmed as persisted to remote data source, especially when further mutations are being made.\r\n\r\n### First-Class Cache\r\n\r\nApplications should cache as much as possible, and read from cache as much as possible, using network communication sparingly, even if only portions of a model are able to be cached or read from cache. \r\n\r\n### Data-Aware Navigation \r\n\r\nApplications should wait until a new view has enough data to render before destroying a previous view and rendering the new view. And should not automatically navigate if operation takes too long, but prompt user to manually navigate to new view.\r\n\r\n## Layers of Solutions\r\n\r\nNot all of the above best practices can be solved by frameworks or libraries, but the design of Angular core can be considered in ways that make these best practices more within reach for developers. These are the layers at which these best practices are being made more possible to achieve: \r\n\r\n * Good core support\r\n   * The highest priority is to make the core of Angular 2 play nicely with all kinds of data, regardless of how it's structured, how it's wrapped, where it comes from, or how it gets to the app. Two existing examples of these solutions are [pipes](https://angular.io/docs/js/latest/api/pipes/) and [zones](https://github.com/angular/zone.js/), with more solutions being designed or considered, such as deeper integration of services with Angular's router and compiler to support prioritized data fetching and rendering, as well as support server-side rendering.\r\n * Browser Wrappers\r\n   * Browsers now provide many tools to solve hard problems with data, such as persistence and asset caching. These tools are not always easy to use, and often difficult to test. Here are some native APIs for which Angular will provide thin wrappers around, as well as the approach being taken in the implementation:\r\n     * HTTP APIs (Status: In-progress, [first commit](https://github.com/angular/angular/commit/21568106b114943b59ce37832d82c8fb9a63285b)) (`[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)`, `[fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)`, etc). Wrappers will provide a composable, Observable-based interface, as well as simplify the process of performing a request. The abstraction will improve mocking and testability, and will make it possible to create isomorphic code to run in different environments (JS in browser, JS in node, Dart, ServiceWorker, etc) by replacing the underlying transport (i.e. `XMLHttpRequest`) using dependency injection. The Http library will provide conveniences to simplify the use of techniques such as request retrying, short polling, long polling, and request cancellation. It will also focus on reducing boilerplate and complexity for projects and teams of all sizes.\r\n     * LocalStorage and SessionStorage (Status: Planned): These APIs will provide mocks to allow testing code without interacting with real browser storage APIs. The abstraction will also provide an [Observable](https://github.com/zenparsing/es-observable) interface on top of the APIs, which will allow subscription to changes to values in the store, specified by key.\r\n     * IndexedDB (Status: Planned)\r\n     * WebSocket (Status: Planned)\r\n     * ServiceWorker/AppCache\r\n * First-Class Libraries\r\n   * Network State (Status: Research)\r\n   * Task Scheduler (Status: Research)\r\n   * Model Metadata (Status: Research)\r\n   * View State Preservation (Status: Research) i.e. preserve the in-memory model and scroll position to survive OS-forced refresh on mobile browsers where memory is scarce.\r\n * First-Class and Third-Party Data Frameworks\r\n   * Tactical\r\n   * Falcor\r\n   * Firebase/AngularFire\r\n   * Angular-Meteor\r\n   * Restangular\r\n   * Lovefield\r\n   * BreezeJS\r\n   * etc\r\n\r\n## Further Reading\r\n\r\n * @jeffbcross and @synalx present [The Future of Data in Angular](https://www.youtube.com/watch?v=Bm3eDgZZMFs) at ng-vegas 2015.\r\n\r\n","google":"UA-40960703-2","note":"Don't delete this file! It's used internally to help with page regeneration."}